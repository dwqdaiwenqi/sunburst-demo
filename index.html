<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sunburst</title>
</head>
<body>
  <style>
    canvas{
      border:1px solid teal;
    }
  </style>
  <!-- <script src="./cax.js"></script> -->
  <script type="module">
    import wrappedData from './sunburst-data.js'

    // console.log('wrappedData',wrappedData)
    // window.$ = window.cax

    onload = ()=>{
      
      let config = {
        x:500*.5,
        y:500*.5,
        r:200,
        levels:[
          {color:'#536686'},
          {color:'#5284f5'},
          {color:'#b5cbfd'}
        ],
        gap:6
      }


      onclick = (e)=>{
        const [x,y] = [
          e.pageX - stage.$c.offsetLeft,
          e.pageY - stage.$c.offsetTop
        ]

        stage.elements.forEach(item=>{
          if(item.inPath(x,y)){

            item.fillStyle = 'pink'
          }
        })
       
      }

      let Stage = (w,h,$el)=>{
        let that = {
          elements:[],
          init(){
            let $c = document.createElement('canvas')
            this.$c = $c
            this.c = $c.getContext('2d')
            $c.width = w
            $c.height = h
            $el.appendChild($c)

            return this
          },
          tick(fn){
            let that = this
            requestAnimationFrame(function callee(){
              requestAnimationFrame(callee)
              that.c.clearRect(0,0,w,h)

              that.update()
            })

          },
          update(){
            this.elements.forEach(element=>{
              element.update(this.c)

              if(element.elements){
                element.elements.forEach(item=>{
                  item.update(this.c)
                })
              }
            })
          },
          add(element){
            element.c = this.c
            this.elements.push(element)
          }
        }
        return that.init()
      }


      let Line = ({x1,y1,x2,y2})=>{
        let that = {
          lineWidth:1,
          strokeStyle:'black',
          init(){
            this.x1 = x1
            this.x2 = x2
            this.y1 = y1
            this.y2 = y2
            return this
          },
          update(c){
            c.save()
            c.lineWidth = this.lineWidth
            c.strokeStyle = this.strokeStyle
            c.beginPath()
            c.moveTo(this.x1,this.y1)
            c.lineTo(this.x2,this.y2)
            c.closePath()
            c.stroke()
            c.restore()
          }
        }
        return that.init()
      }

      
      let Text = ({
        text
      })=>{
        let that = {
          font:'14px',
          textBaseline:'middle',
          textAlign:'center',
          fillStyle:'white',
          x:0,
          y:0,
          init(){
            this.text = text;
            return this
          },
          update(c){
            c.save()
            c.font=this.font
            c.fillStyle = this.fillStyle
            c.textBaseline = this.textBaseline
            c.textAlign = this.textAlign
            c.fillText(text,this.x,this.y);
            c.restore()
          }
        }
        return that.init()
      }

      let Ring = ({
        innerRadius,
        outerRadius,
        startRadian,
        endRadian
      })=>{
        let that = {
          fillStyle:'black',
          x:0,
          y:0,
          elements:[],
          init(){
            this.innerRadius = innerRadius
            this.outerRadius = outerRadius
            this.startRadian = startRadian
            this.endRadian = endRadian
            return this;
          },
          getCenterPo(){
            let half = (a,b)=>a+(b-a)*.5
            let radian = half(this.startRadian,this.endRadian)
            let radius = half(this.innerRadius,this.outerRadius)
            return {
              x: !this.innerRadius?this.x:Math.cos(radian)*radius+this.x,
              y: !this.innerRadius?this.x:Math.sin(radian)*radius+this.y
            }
          },
          getMiddleOfEdge(){
            let half = (a,b)=>a+(b-a)*.5
            let radian = half(this.startRadian,this.endRadian)
            let radius = this.outerRadius
            return {
              x: Math.cos(radian)*radius+this.x,
              y: Math.sin(radian)*radius+this.y,
              normalize:{
                x:Math.cos(radian),
                y:Math.sin(radian)
              }
            }
          },
          inPath(x,y){

            this.drawPath(this.c)
            return this.c.isPointInPath(x,y)
         
          },
          drawPath(c){
            let {innerRadius,outerRadius,startRadian,endRadian} = this

            let [cx,cy] = [this.x,this.y]

            c.save()

            c.beginPath()

            c.moveTo(
              Math.cos(startRadian)*innerRadius+cx,
              Math.sin(startRadian)*innerRadius+cy
            )
            c.lineTo(
              Math.cos(startRadian)*outerRadius+cx,
              Math.sin(startRadian)*outerRadius+cy
            )


            c.arc(cx,cy,outerRadius,startRadian,endRadian)

            c.lineTo(
              Math.cos(endRadian)*innerRadius+cx,  //圆弧起点x
              Math.sin(endRadian)*innerRadius+cy, //圆弧起点y
            )


            c.arc(
              cx,// 圆心x
              cy,// 圆心y
              innerRadius, //圆弧的半径
              endRadian, //圆弧的开始弧度
              startRadian, //圆弧的结束弧度
              true, // 逆时针绘制
            );
            c.closePath()

            // console.log('this.fillStyle',this.fillStyle)
            c.fillStyle = this.fillStyle
            c.strokeStyle = this.strokeStyle
            c.lineWidth = this.lineWidth

            c.stroke();
          },
          update(c){

            this.drawPath(c);
            c.stroke();
            c.fill();
            c.restore();
          },
          add(element){
            this.elements.push(element)
          }
        }
        return that.init()
      }

      let stage = Stage(500,500,document.body)

      // let ring = Ring({
      //   innerRadius:50,
      //   outerRadius:150,
      //   startRadian:.1,
      //   endRadian:.55,
      // })
      // ring.fillStyle = 'aqua'

      


      let avgRadius = config.r/wrappedData.length

      for(let i = 0,len = wrappedData.length;i<len;i++){

        // if(i!==0) continue
        const children = wrappedData[i]
        let radius = i/len*config.r
        let co = config.levels[i].color
        

        let depth2Childs = []
        for(let j = 0,len=children.length;j<len;j++){
          let childData = children[j]

          // console.log(childData)
          let radian = childData.rad

          let startRadian
          let endRadian

          if(j === 0){
            startRadian = 0
            endRadian =startRadian+ radian 
          }else{
            startRadian = depth2Childs[j-1].endRadian 
            endRadian = startRadian + radian
          }
          
          let ring = Ring({
            innerRadius:radius,
            outerRadius:radius+avgRadius,
            startRadian,
            endRadian,
          })
          ring.x = config.x
          ring.y = config.y
          ring.fillStyle = co
          ring.strokeStyle = 'white'
          ring.lineWidth = config.gap

          let textName = Text({text:childData.name})
          let {x,y} = ring.getCenterPo()
          ring.add(textName)
          textName.x = x
          textName.y = y
          let textValue = Text({text:childData.value})
          ring.add(textValue)
          textValue.textAlign = 'right'
          textValue.x = x
          textValue.y = y+15


          let {x:x1,y:y1,normalize} = ring.getMiddleOfEdge()
          
          let line = Line({
            x1,
            y1,
            x2:x1+normalize.x*10,
            y2:y1+normalize.y*10
          })
          ring.add(line)

          let line2 =Line({
            x1:line.x2,
            y1:line.y2,
            x2:line.x2+normalize.x*50,
            y2:line.y2
          })
          ring.add(line2)
          
         


          // console.log('ring center po',ring.getCenterPo())

          // console.log('childData',childData)

          depth2Childs.push(ring)
          
          stage.add(ring)
        }

        console.log('depth2Childs',depth2Childs)
      }

      
      stage.tick(()=>{

        stage.update()
      })
    }
  </script>
</body>
</html>